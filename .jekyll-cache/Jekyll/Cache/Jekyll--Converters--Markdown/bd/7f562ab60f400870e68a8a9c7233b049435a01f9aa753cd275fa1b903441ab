I"Av<h2 id="前言">前言</h2>

<p>函數式編程 (Functional Programming) 一直都是大家在討論卻又很少在專案中看到的一種編程模式。雖然少見，但還是有不少的函數式編程語言像是： Haskell, Scala, Closure 等等被開發出來在各式各樣的專案中使用。但是，這些語言很少被拿來當成開發前端的工具。今天要跟各位介紹的就是為前端人所設計的函數式編程語言： Elm。</p>

<h2 id="介紹">介紹</h2>

<p>Elm 是一個強型別的函數式編程語言。我們在最終會將它編譯成 JavaScript 以便於在瀏覽器上使用。在它的<a href="http://elm-lang.org/">官網</a>你可以看到它所主打的一些特色，我個人認為以下幾點是非常吸引人的:</p>

<ol>
  <li>不會有執行階段錯誤 (Runtime Error)</li>
  <li>Render 的速度非常快</li>
  <li>語法簡潔易懂，易於測試</li>
  <li>超級友善的錯誤訊息</li>
  <li>良好的設計架構 (<a href="https://github.com/evancz/elm-architecture-tutorial">Elm-Architecture</a>)</li>
</ol>

<p>不會有執行階段錯誤代表著我們可以避免使用者直接看到程式在他面前爆炸，Elm 在編譯階段就會抓出許多潛在的錯誤，大大降低出包率。</p>

<p>Render 的速度在現在這個講求速度的年代已經是基本配備了，特別提出來的原因是在於它與目前最熱門的 React 一樣使用了 Virtual DOM 的技術來提高效能並號稱比 React 還快。以下是官方提供的比較圖給各位參考：</p>

<p><img src="http://elm-lang.org/diagrams/sampleResults.png" alt="Elm 效能比較圖" /></p>

<p>由於在 Elm 的世界裡只有 Immutable Data 和無副作用的函數 (Pure Function)，在開發時會變得很容易測試。當不小心寫錯程式時，貼心的錯誤提示也能夠幫助你快速修正。</p>

<p>最後提到的設計架構叫 <a href="https://github.com/evancz/elm-architecture-tutorial">Elm-Architecture</a>。是作者提出的一種單向資料流設計模式。就連 React 御用的 Redux 當初也是從 Elm 這裡取得靈感才被開發出來的喔。</p>

<h2 id="語法">語法</h2>

<p>說了這麼多介紹，也是要趕快來看看程式碼該怎麼寫吧。由於 Elm 是用 Haskell 開發出來的，它們兩個的語法可說是非常接近，熟悉 Haskell 的讀者應該會覺得非常親切。以下的語法是以目前(2016-04)最新的版本 <code class="language-plaintext highlighter-rouge">v0.16.0</code> 作為範例。</p>

<h3 id="function">Function</h3>

<div class="language-elm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">add</span> <span class="n">x</span> <span class="n">y</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>

<span class="n">add</span> <span class="o">=</span> <span class="p">(</span><span class="o">\</span><span class="n">x</span> <span class="n">y</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span>

<span class="n">add</span> <span class="mi">1</span> <span class="mi">2</span> <span class="c1">-- 3</span>
</code></pre></div></div>

<p>相當於 JavaScript 的</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">add</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">x</span> <span class="o">+</span> <span class="nx">y</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// ES6</span>
<span class="kd">var</span> <span class="nx">add</span> <span class="o">=</span> <span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">x</span> <span class="o">+</span> <span class="nx">y</span><span class="p">;</span>

<span class="nx">add</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span> <span class="c1">// 3</span>
</code></pre></div></div>

<p>上面的例子使用了兩種不同的方法建立 <code class="language-plaintext highlighter-rouge">add</code> 函數 (正規與 inline)。最行一行則是使用函式的方法。而出現在最後的 <code class="language-plaintext highlighter-rouge">--</code> 在 Elm 中就是註解。</p>

<p>如果需要有類似局部變數 (local variable) 的時機時可以使用 <code class="language-plaintext highlighter-rouge">let...in</code> 的寫法：</p>

<div class="language-elm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">cube</span> <span class="n">x</span> <span class="o">=</span>
    <span class="k">let</span>
        <span class="n">squaredX</span> <span class="o">=</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span>
    <span class="k">in</span> <span class="n">squaredX</span> <span class="o">*</span> <span class="n">x</span>

<span class="n">cube</span> <span class="mi">5</span> <span class="c1">--125</span>
</code></pre></div></div>

<p>在 Elm 世界的函數裡，回傳的值會是最後執行到的那行的結果。</p>

<h3 id="常用資料結構">常用資料結構</h3>

<p>Elm 提供了各式各樣的資料結構供我們使用，本篇會針對常用的三個 (List, Tuple 及 Record) 做介紹。較不常用的 Array, Set 和 Dict 歡迎大家參考這篇 <a href="http://tech.noredink.com/post/140646140878/data-structures-in-elm">Data Structures in Elm</a>。</p>

<h4 id="list">List</h4>

<p>List 類似於 JavaScript 中的 Array，但又不全然相同。在原生的 Elm 中，我們無法像在 JavaScript 裡一樣靠 index 來取值，如果需要這功能的話需要額外載入<a href="http://package.elm-lang.org/packages/circuithub/elm-list-extra/3.10.0/List-Extra">elm-list-extra</a> 或使用 Elm 提供的 Array。需要特別注意的是在 List 中的每個元素必須是<strong>相同</strong>型別的。</p>

<div class="language-elm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">xs</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="p">]</span>
<span class="n">xs</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">::</span> <span class="p">[</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="p">]</span>
<span class="n">xs</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">++</span> <span class="p">[</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="p">]</span>
</code></pre></div></div>

<p>以上三行都代表著一個叫 <code class="language-plaintext highlighter-rouge">xs</code> 的 List 包含了 1,2,3,4 的值在裡面。第一種表達法相當直觀，這邊就不多作解釋。第二種的 <code class="language-plaintext highlighter-rouge">::</code> 在 Elm 中稱作 <code class="language-plaintext highlighter-rouge">cons</code>，相當於 JavaScript 中的 <code class="language-plaintext highlighter-rouge">unshift</code>。最後一種做法則是類似於 JS 中的 <code class="language-plaintext highlighter-rouge">concat</code>，會將前後兩個 List 合併為一個。有興趣瞭解其他關於 List 方法的讀者可到<a href="http://package.elm-lang.org/packages/elm-lang/core/3.0.0/List">官方文件</a>查詢。</p>

<h4 id="tuple">Tuple</h4>

<p>Tuple 在許多程式語言中都有，它有點像是簡易版的 List。差別在於內部元素的數量是在建立時就決定的，無法像 List 一樣使用 <code class="language-plaintext highlighter-rouge">cons</code> 或其他方法修改，同時內部的元素也可以是<strong>不同</strong>的型別。</p>

<div class="language-elm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">t1</span> <span class="o">=</span> <span class="p">(</span><span class="s">"</span><span class="s2">Foo"</span><span class="o">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">t2</span> <span class="o">=</span> <span class="p">(</span><span class="s">"</span><span class="s2">bar"</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="p">[</span><span class="kt">True</span><span class="o">,</span> <span class="kt">False</span><span class="p">])</span>

<span class="n">fst</span> <span class="n">t1</span> <span class="c1">-- "Foo"</span>
<span class="n">snd</span> <span class="n">t2</span> <span class="c1">-- 2</span>
</code></pre></div></div>

<p>我們可以使用 <code class="language-plaintext highlighter-rouge">fst</code> (first 的縮寫) 來取得 Tuple 中第一個元素，<code class="language-plaintext highlighter-rouge">snd</code> (second 的縮寫) 來取得第二個元素。 更多和 Tuple 相關的文件請到<a href="http://elm-lang.org/">官網</a>查詢。</p>

<h4 id="record">Record</h4>

<p>Record 類似於 JavaScript 中的 Object。</p>

<div class="language-elm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">person</span> <span class="o">=</span> <span class="p">{</span> <span class="n">name</span> <span class="o">=</span> <span class="s">"</span><span class="s2">Rhadow"</span><span class="o">,</span> <span class="n">age</span> <span class="o">=</span> <span class="mi">18</span> <span class="p">}</span>
<span class="n">person</span><span class="o">.</span><span class="n">name</span> <span class="c1">-- "Rhadow"</span>
<span class="o">.</span><span class="n">age</span> <span class="n">person</span> <span class="c1">-- 18</span>

<span class="n">updatedPerson</span> <span class="o">=</span> <span class="p">{</span> <span class="n">person</span> <span class="o">|</span> <span class="n">name</span> <span class="o">=</span> <span class="s">"</span><span class="s2">Amy"</span> <span class="p">}</span>
<span class="n">updatedPerson</span><span class="o">.</span><span class="n">name</span> <span class="c1">-- "Amy"</span>
<span class="n">updatedPerson</span><span class="o">.</span><span class="n">age</span> <span class="c1">-- 18</span>

<span class="n">person</span><span class="o">.</span><span class="n">name</span> <span class="c1">-- "Rhadow"</span>
</code></pre></div></div>

<p>相當於 JavaScript (ES7) 中的</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">person</span> <span class="o">=</span> <span class="p">{</span> <span class="na">name</span><span class="p">:</span> <span class="dl">"</span><span class="s2">Rhadow</span><span class="dl">"</span><span class="p">,</span> <span class="na">age</span><span class="p">:</span> <span class="mi">18</span> <span class="p">};</span>
<span class="nx">person</span><span class="p">.</span><span class="nx">name</span> <span class="c1">// "Rhadow"</span>
<span class="nx">person</span><span class="p">.</span><span class="nx">age</span> <span class="c1">// 18</span>

<span class="kd">let</span> <span class="nx">updatedPerson</span> <span class="o">=</span> <span class="p">{</span> <span class="p">...</span><span class="nx">person</span><span class="p">,</span> <span class="na">name</span><span class="p">:</span> <span class="dl">"</span><span class="s2">Amy</span><span class="dl">"</span> <span class="p">}</span>
<span class="nx">updatedPerson</span><span class="p">.</span><span class="nx">name</span> <span class="c1">// "Amy"</span>
<span class="nx">updatedPerson</span><span class="p">.</span><span class="nx">age</span> <span class="c1">// 18</span>

<span class="nx">person</span><span class="p">.</span><span class="nx">name</span> <span class="c1">// "Rhadow"</span>
</code></pre></div></div>

<p>上例比較特別的地方在於 Elm 把 <code class="language-plaintext highlighter-rouge">.xxx</code> (xxx 為 key 值) 也做成了一個函數，所以我們不只可以用 <code class="language-plaintext highlighter-rouge">person.name</code> 也可以用 <code class="language-plaintext highlighter-rouge">.name person</code> 來取得同樣的值。</p>

<p>另一個特色是在 Elm 裡，所有的資料都是 Immutable，因此當我們想要更新 person 內部的值時需要指派一個新的變數 (<code class="language-plaintext highlighter-rouge">updatedPerson</code>) 給它，同時原本的變數 (<code class="language-plaintext highlighter-rouge">person</code>) 會保持不變。</p>

<h3 id="模式匹配-pattern-matching">模式匹配 (Pattern Matching)</h3>

<p>模式匹配是一個非常強大的功能，它有點類似於 ES6 中的 destructuring，但又附帶了一些額外的功能。</p>

<div class="language-elm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">head</span><span class="err">'</span> <span class="n">list</span> <span class="o">=</span>
    <span class="k">case</span> <span class="n">list</span> <span class="k">of</span>
        <span class="p">[]</span> <span class="o">-&gt;</span> <span class="kt">Nothing</span>
        <span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="kt">Just</span> <span class="n">x</span>
        <span class="n">x</span><span class="o">::</span><span class="n">xs</span> <span class="o">-&gt;</span> <span class="kt">Just</span> <span class="n">x</span>

<span class="n">head</span><span class="err">'</span> <span class="p">[]</span> <span class="c1">-- Nothing</span>
<span class="n">head</span><span class="err">'</span> <span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="c1">-- Just 2</span>
<span class="n">head</span><span class="err">'</span> <span class="p">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="p">]</span> <span class="c1">-- Just 1</span>
</code></pre></div></div>

<p>上面的例子是一個叫做 <code class="language-plaintext highlighter-rouge">head'</code> 的函數，用來幫我們取出 list 中第一個元素。是的，你沒看錯，在 Elm 中 <code class="language-plaintext highlighter-rouge">'</code> 可被拿來與字串一起使用當成函數的名稱。 <code class="language-plaintext highlighter-rouge">case ... of ...</code> 類似於我們熟知的 <code class="language-plaintext highlighter-rouge">switch</code>。緊接著 <code class="language-plaintext highlighter-rouge">case</code> 下面的三行列出了 <code class="language-plaintext highlighter-rouge">list</code> 這個變數的所有可能以及應對的方法。</p>

<p>當 list 為空時，我們會回傳 <code class="language-plaintext highlighter-rouge">Nothing</code>。<code class="language-plaintext highlighter-rouge">Nothing</code> 有點類似於 JS 中的 <code class="language-plaintext highlighter-rouge">null</code> 或 <code class="language-plaintext highlighter-rouge">undefined</code>，<code class="language-plaintext highlighter-rouge">Nothing</code> 與 <code class="language-plaintext highlighter-rouge">Just xxx</code> 的細節會在接下來介紹型別的段落討論。第二個可能是當 list 只有一個元素時，我們直接將該元素回傳。最後一個可能則是含有多個元素時的應對，這裡可以看到模式匹配強大的地方。假設 list 為 <code class="language-plaintext highlighter-rouge">[1,2,3]</code> 時，我們知道 <code class="language-plaintext highlighter-rouge">1 :: [2, 3] == [1, 2, 3]</code>，模式匹配會自動將我們指派的變數 <code class="language-plaintext highlighter-rouge">x</code> 設為 <code class="language-plaintext highlighter-rouge">1</code> 和 <code class="language-plaintext highlighter-rouge">xs</code> 設為 <code class="language-plaintext highlighter-rouge">[2, 3]</code> 以利作為後續利用。</p>

<h3 id="型別">型別</h3>

<p>我們知道 Elm 是一個強型別的語言，除了提供一些常見的型別像是 <code class="language-plaintext highlighter-rouge">Int</code>, <code class="language-plaintext highlighter-rouge">Float</code>, <code class="language-plaintext highlighter-rouge">String</code>, <code class="language-plaintext highlighter-rouge">Bool</code> 等等…也同時提供給開發者自創型別的方法。得到新型別的手法有兩種，一種是建立型別的別名，另一種則是直接建立新的型別。在講如何建立型別之前，讓我們先看看如何將這些型別定義到我們已知的知識上吧。</p>

<p>如果我們拿剛提到的 <code class="language-plaintext highlighter-rouge">add</code> 例子來看，加入型別後的程式會像是以下：</p>

<div class="language-elm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">a</span><span class="p">:</span> <span class="kt">Int</span>
<span class="n">a</span> <span class="o">=</span> <span class="mi">1</span>

<span class="n">b</span><span class="p">:</span> <span class="kt">Int</span>
<span class="n">b</span> <span class="o">=</span> <span class="mi">2</span>

<span class="n">add</span><span class="p">:</span> <span class="kt">Int</span> <span class="o">-&gt;</span> <span class="kt">Int</span> <span class="o">-&gt;</span> <span class="kt">Int</span>
<span class="n">add</span> <span class="n">x</span> <span class="n">y</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>

<span class="n">c</span><span class="p">:</span> <span class="kt">Int</span>
<span class="n">c</span> <span class="o">=</span> <span class="n">add</span> <span class="n">a</span> <span class="n">b</span> <span class="c1">-- c == 3</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">:</code> 單一冒號代表定義變數的型別，Elm 提倡在寫程式時最好將型別定義一同寫入。這邊比較有趣的是 <code class="language-plaintext highlighter-rouge">add: Int -&gt; Int -&gt; Int</code>，函數的型別定義規則是最後一個箭頭指向的型別就是被回傳的值的型別，而其他的則是輸入參數的型別。因此，<code class="language-plaintext highlighter-rouge">add</code> 的定義是會接受兩個 <code class="language-plaintext highlighter-rouge">Int</code> 並回傳一個 <code class="language-plaintext highlighter-rouge">Int</code>。</p>

<h4 id="型別別名-type-alias">型別別名 (type alias)</h4>

<p>有時候，單純的基本型別可能無法完全詮釋我們想要表達的意思，也有可能是資料結構太複雜，我們想用一個簡單的名稱稱呼它，這時型別別名就可派上用場。</p>

<div class="language-elm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="k">alias</span> <span class="kt">Name</span> <span class="o">=</span> <span class="kt">String</span>
<span class="k">type</span> <span class="k">alias</span> <span class="kt">Age</span> <span class="o">=</span> <span class="kt">Int</span>
<span class="k">type</span> <span class="k">alias</span> <span class="kt">Person</span> <span class="o">=</span>
    <span class="p">{</span> <span class="n">name</span><span class="p">:</span> <span class="kt">String</span>
    <span class="o">,</span> <span class="n">age</span><span class="p">:</span> <span class="kt">Int</span>
    <span class="p">}</span>

<span class="n">createPerson</span><span class="p">:</span> <span class="kt">Name</span> <span class="o">-&gt;</span> <span class="kt">Age</span> <span class="o">-&gt;</span> <span class="kt">Person</span>
<span class="n">createPerson</span> <span class="n">name</span> <span class="n">age</span> <span class="o">=</span>
    <span class="p">{</span> <span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
    <span class="o">,</span> <span class="n">age</span> <span class="o">=</span> <span class="n">age</span>
    <span class="p">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">type alias Name = String</code> 的意思可以翻譯為 <code class="language-plaintext highlighter-rouge">將 Name 設定為 String 的另一個別名</code>。如此一來，我們就可以像這樣定義:</p>

<p><code class="language-plaintext highlighter-rouge">createPerson: Name -&gt; Age -&gt; Person</code></p>

<p>而不是</p>

<p><code class="language-plaintext highlighter-rouge">createPerson: String -&gt; Int -&gt; Person</code></p>

<p>雖然兩者對程式來說相同，但前者對人類來說更清楚明瞭。</p>

<h4 id="建立自創型別與-union-type">建立自創型別與 Union Type</h4>

<p>自創型別的方法如下：</p>

<div class="language-elm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- Example 1.</span>
<span class="k">type</span> <span class="kt">Directions</span> <span class="o">=</span> <span class="kt">Up</span> <span class="o">|</span> <span class="kt">Down</span> <span class="o">|</span> <span class="kt">Left</span> <span class="o">|</span> <span class="kt">Right</span>

<span class="c1">-- Example 2.</span>
<span class="k">type</span> <span class="kt">Maybe</span> <span class="n">a</span> <span class="o">=</span> <span class="kt">Nothing</span> <span class="o">|</span> <span class="kt">Just</span> <span class="n">a</span>
</code></pre></div></div>

<p>我們可以創造兩種不同款式的型別，第一種像是上例的 <code class="language-plaintext highlighter-rouge">Directions</code> 比較直觀簡單，在這型別下只會有四種可能的值，就是我們定義的 <code class="language-plaintext highlighter-rouge">Up</code>，<code class="language-plaintext highlighter-rouge">Down</code>，<code class="language-plaintext highlighter-rouge">Left</code>，<code class="language-plaintext highlighter-rouge">Right</code>。在使用上的話我們可以這麼做：</p>

<div class="language-elm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">convertDirectionsToInt</span><span class="p">:</span> <span class="kt">Directions</span> <span class="o">-&gt;</span> <span class="kt">Int</span>
<span class="n">convertDirectionsToInt</span> <span class="n">dir</span> <span class="o">=</span>
    <span class="k">case</span> <span class="n">dir</span> <span class="k">of</span>
        <span class="kt">Up</span> <span class="o">-&gt;</span> <span class="mi">1</span>
        <span class="kt">Down</span> <span class="o">-&gt;</span> <span class="mi">2</span>
        <span class="kt">Left</span> <span class="o">-&gt;</span> <span class="mi">3</span>
        <span class="kt">Right</span> <span class="o">-&gt;</span> <span class="mi">4</span>

<span class="n">convertDirectionsToInt</span> <span class="kt">Up</span> <span class="c1">-- 1</span>
</code></pre></div></div>

<p>另一種則被稱為 Union Type，指的是我們可以將其它已存在的型別組合進我們自創的型別中。範例中我們建立了一個叫 <code class="language-plaintext highlighter-rouge">Maybe</code> 的型別，後面跟著的 <code class="language-plaintext highlighter-rouge">a</code> 是所謂的 <code class="language-plaintext highlighter-rouge">型別變數</code>，再更後面則是型別的值。我們可以自由在型別變數中帶入其他的型別如下：</p>

<div class="language-elm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- 把 String 帶入 a</span>
<span class="n">maybeString</span><span class="p">:</span> <span class="kt">Maybe</span> <span class="kt">String</span>
<span class="n">maybeString</span> <span class="o">=</span> <span class="kt">Just</span> <span class="s">"</span><span class="s2">I am a string"</span>

<span class="c1">-- 把 Int 帶入 a</span>
<span class="n">maybeInt</span><span class="p">:</span> <span class="kt">Maybe</span> <span class="kt">Int</span>
<span class="n">maybeInt</span> <span class="o">=</span> <span class="kt">Just</span> <span class="mi">1</span>

<span class="n">anotherMaybeInt</span><span class="p">:</span> <span class="kt">Maybe</span> <span class="kt">Int</span>
<span class="n">maybeInt</span> <span class="o">=</span> <span class="kt">Nothing</span>
</code></pre></div></div>

<p>以上三個變數都是屬於 <code class="language-plaintext highlighter-rouge">Maybe a</code> 型別，但隨著帶入的 <code class="language-plaintext highlighter-rouge">a</code> 不同，型別裡的值也會跟著改變。當然你也可以建立更複雜的 Union Type，例如:</p>

<div class="language-elm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="kt">Directions</span> <span class="n">a</span> <span class="n">b</span> <span class="o">=</span> <span class="kt">Up</span> <span class="n">a</span> <span class="o">|</span> <span class="kt">Down</span> <span class="n">b</span> <span class="o">|</span> <span class="kt">Left</span> <span class="n">a</span> <span class="n">b</span> <span class="o">|</span> <span class="kt">Right</span>
</code></pre></div></div>

<h3 id="模組與條件判斷">模組與條件判斷</h3>

<p>呼～把困難的都說的差不多了，最後來點簡單的吧。</p>

<p>Elm 載入模組的方法非常簡單，假設我們有一個叫 <code class="language-plaintext highlighter-rouge">Html</code> 的模組並且我們想使用 <code class="language-plaintext highlighter-rouge">div</code> 這個函數時有以下幾種方法：</p>

<div class="language-elm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- Example 1.</span>
<span class="k">import</span> <span class="kt">Html</span>

<span class="c1">-- Example 2.</span>
<span class="k">import</span> <span class="kt">Html</span> <span class="k">as</span> <span class="kt">MyHtml</span>

<span class="c1">--Example 3.</span>
<span class="k">import</span> <span class="kt">Html</span> <span class="k">exposing</span> <span class="p">(</span><span class="n">div</span><span class="p">)</span>

<span class="c1">--Example 4.</span>
<span class="k">import</span> <span class="kt">Html</span> <span class="k">exposing</span> <span class="p">(</span><span class="o">..</span><span class="p">)</span>
</code></pre></div></div>

<p>在範例一中想使用 <code class="language-plaintext highlighter-rouge">div</code> 時要這樣呼叫: <code class="language-plaintext highlighter-rouge">Html.div</code></p>

<p>在範例二中想使用 <code class="language-plaintext highlighter-rouge">div</code> 時要這樣呼叫: <code class="language-plaintext highlighter-rouge">MyHtml.div</code></p>

<p>在範例三中想使用 <code class="language-plaintext highlighter-rouge">div</code> 可以直接呼叫: <code class="language-plaintext highlighter-rouge">div</code>，但想使用其他函數時還是得加上命名空間: <code class="language-plaintext highlighter-rouge">Html.span</code></p>

<p>在範例四中可直接呼叫任意在 Html 中的函數: <code class="language-plaintext highlighter-rouge">div</code>, <code class="language-plaintext highlighter-rouge">span</code>, <code class="language-plaintext highlighter-rouge">text</code>…</p>

<p>輸出模組時只需要在檔案最開始加入:</p>

<div class="language-elm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">module</span> <span class="kt">MyModule</span> <span class="n">where</span>

<span class="c1">--接下來寫的內容都可被輸出</span>
</code></pre></div></div>

<p>Elm 的條件判斷相當簡潔，只有 <code class="language-plaintext highlighter-rouge">if..then..else..</code></p>

<div class="language-elm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="n">sleepingHours</span> <span class="o">&lt;</span> <span class="mi">8</span> <span class="k">then</span>
    <span class="s">"</span><span class="s2">Get some sleep!!"</span>
<span class="k">else</span>
    <span class="s">"</span><span class="s2">Write more code!!"</span>
</code></pre></div></div>

<p>你所熟知跟迴圈有關的 <code class="language-plaintext highlighter-rouge">for</code> 與 <code class="language-plaintext highlighter-rouge">while</code> 都不存在，在 Functional 的世界裡，你可以用 <code class="language-plaintext highlighter-rouge">map</code>， <code class="language-plaintext highlighter-rouge">filter</code>， <code class="language-plaintext highlighter-rouge">fold</code>(在 JS 叫 <code class="language-plaintext highlighter-rouge">reduce</code>) 或其他的方法來解決需要迴圈的問題。</p>

<h2 id="結語">結語</h2>

<p>大家都知道前端的變動非常的快，但在了解 Elm 的一些基本概念後，你會發現前端的改動和 Elm 所前進的方向是相同的。例如：Facebook 推出的 ImmutableJS，單一資料流的 Redux，越來越多人關注的 Reactive Programming 等等都已經是 Elm 的基本配備 (是的，Elm 有內建類似 Observables 的東西，叫做 <a href="http://elm-lang.org/guide/reactivity">Signal</a>)。 當然，Elm 也是有它的弱勢，像是目前不支援 Server Side Rendering 以及社群太小還沒太多有用的套件。</p>

<p>最後個人的一點小心得：函數式編程語言有別於我們所習慣的寫程式方法，但有時候如果打開心胸去學習這種非主流的思考方式時，也會幫助你在你的程式生涯裡更上一層樓喔。</p>
:ET