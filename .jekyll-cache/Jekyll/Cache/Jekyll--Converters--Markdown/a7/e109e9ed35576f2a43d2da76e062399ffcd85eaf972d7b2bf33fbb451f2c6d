I"$Q<h2 id="前言">前言</h2>

<p>多數人在學習 Elm 時都會看到 <a href="https://github.com/evancz/elm-architecture-tutorial">Elm Architecture</a> 這個教學文件，也都應該會遇到那個神秘的 <code class="language-plaintext highlighter-rouge">address</code>。本篇會使用最簡單的 Counter 例子讓大家瞭解 <code class="language-plaintext highlighter-rouge">address</code> 與這個架構的關聯性。本篇文章使用的 Elm 是目前 (2016-04) 最新的版本 <code class="language-plaintext highlighter-rouge">v0.16.0</code>。</p>

<p><strong>2016-11-14 更新： 最新版本的 Elm 已經把 <code class="language-plaintext highlighter-rouge">Signal</code> 拿掉了，若有興趣了解過往的 Elm 是如何處理資料流的話再往下讀吧。這邊是<a href="http://elm-lang.org/blog/farewell-to-frp">官方說明文件</a>。</strong></p>

<h2 id="需求">需求</h2>

<p>首先來瞭解一下我們的目標是做出一個簡單的<a href="http://evancz.github.io/elm-architecture-tutorial/examples/1.html">計數器</a>，這也是<a href="https://github.com/evancz/elm-architecture-tutorial">Elm Architecture</a> 教學中的第一個例子。 接下來我們會在不使用 <a href="https://github.com/evancz/start-app">Start-App</a> 這個 library 的幫助下完成這個程式。</p>

<h2 id="model">Model</h2>

<p>首先決定 Model 的型別，由於計數器只需要一個數字，我們走最簡潔路線直接將它設定成 <code class="language-plaintext highlighter-rouge">Int</code> 並把初始值設為 <code class="language-plaintext highlighter-rouge">0</code>。</p>

<div class="language-elm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="k">alias</span> <span class="kt">Model</span> <span class="o">=</span> <span class="kt">Int</span>

<span class="n">init</span><span class="p">:</span> <span class="kt">Model</span>
<span class="n">init</span> <span class="o">=</span> <span class="mi">0</span>

</code></pre></div></div>

<h2 id="action">Action</h2>

<p>Action 決定了我們能夠如何與程式互動。我們的目標只有兩個動作，一個增加，一個減少。</p>

<div class="language-elm highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="k">type</span> <span class="kt">Action</span>
    <span class="o">=</span> <span class="kt">Increase</span>
    <span class="o">|</span> <span class="kt">Decrease</span>
    <span class="o">|</span> <span class="kt">NoOp</span>

</code></pre></div></div>

<p>這裡多了一個 <code class="language-plaintext highlighter-rouge">NoOp</code> (No Operation 縮寫) 作為預設行為，至於為什麼要有這個 Action 會在接下來的內容裡提到。另外，如果你曾經使用過 Redux 架構的話，你會發現這與 Redux 中的 <code class="language-plaintext highlighter-rouge">actionTypes</code> 很類似。</p>

<h2 id="update">Update</h2>

<p><code class="language-plaintext highlighter-rouge">update</code> 包含了這個計數器裡的所有邏輯，對應到 Redux 就是所謂的 <code class="language-plaintext highlighter-rouge">reducer</code>。</p>

<div class="language-elm highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="n">update</span><span class="p">:</span> <span class="kt">Action</span> <span class="o">-&gt;</span> <span class="kt">Model</span> <span class="o">-&gt;</span> <span class="kt">Model</span>
<span class="n">update</span> <span class="n">action</span> <span class="n">model</span> <span class="o">=</span>
    <span class="k">case</span> <span class="n">action</span> <span class="k">of</span>
        <span class="kt">NoOp</span> <span class="o">-&gt;</span> <span class="n">model</span>
        <span class="kt">Increase</span> <span class="o">-&gt;</span> <span class="n">model</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="kt">Decrease</span> <span class="o">-&gt;</span> <span class="n">model</span> <span class="o">-</span> <span class="mi">1</span>

</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">update</code> 的型別定義為 <code class="language-plaintext highlighter-rouge">Action -&gt; Model -&gt; Model</code> ，代表著接收一個 <code class="language-plaintext highlighter-rouge">Action</code> 與原本的 <code class="language-plaintext highlighter-rouge">Model</code>。在經過我們設定的邏輯後，進而產生一個最新的 <code class="language-plaintext highlighter-rouge">Model</code> 給我們。很直覺吧！</p>

<h2 id="view">View</h2>

<p><code class="language-plaintext highlighter-rouge">view</code> 當然就是用來產生使用者介面的函數囉。</p>

<div class="language-elm highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="n">view</span><span class="p">:</span> <span class="kt">Model</span> <span class="o">-&gt;</span> <span class="kt">Html</span>
<span class="n">view</span> <span class="n">model</span> <span class="o">=</span>
    <span class="n">div</span>
        <span class="p">[]</span>
        <span class="p">[</span> <span class="n">button</span> <span class="p">[]</span> <span class="p">[</span> <span class="n">text</span> <span class="s">"</span><span class="s2">-"</span> <span class="p">]</span>
        <span class="o">,</span> <span class="n">span</span> <span class="p">[]</span> <span class="p">[</span><span class="n">text</span> <span class="p">(</span><span class="n">toString</span> <span class="n">model</span><span class="p">)]</span>
        <span class="o">,</span> <span class="n">button</span> <span class="p">[]</span> <span class="p">[</span> <span class="n">text</span> <span class="s">"</span><span class="s2">+"</span><span class="p">]</span>
        <span class="p">]</span>

</code></pre></div></div>

<p>目前的 <code class="language-plaintext highlighter-rouge">view</code> 的型別定義也很直觀，接受資料並根據內容產生出畫面，在這個例子中就是計數器目前的算到的值。</p>

<h2 id="main">Main</h2>

<p>為了要讓 Elm 執行我們剛剛做好的畫面，我們需要透過 <code class="language-plaintext highlighter-rouge">main</code> 把以上函數給串接起來。</p>

<div class="language-elm highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="n">main</span><span class="p">:</span> <span class="kt">Html</span>
<span class="n">main</span> <span class="o">=</span> <span class="n">view</span> <span class="n">init</span>

</code></pre></div></div>

<p>到目前為止的程式碼如下，有興趣的讀者可將程式碼複製貼上到官方提供的<a href="http://elm-lang.org/try">線上編譯器</a>測試:</p>

<script src="https://gist.github.com/Rhadow/22085e7a3cfb1cb9505307f0a855c7d8.js"></script>

<h2 id="signal-mailbox-與-address">Signal, Mailbox 與 Address</h2>

<p>目前程式跑起來了，但是問題在於我們與畫面完全無法互動。我們都知道 Elm 裡的變數都是 Immutable，無法隨意變動。因此，Elm 將反應式編程 (Reactive Programming) 的概念帶入並提供了 <a href="http://package.elm-lang.org/packages/elm-lang/core/3.0.0/Signal">Signal</a> 供開發者使用。</p>

<h3 id="signal">Signal</h3>

<p>Signal 其實就是一個會隨著時間改變的變數，你也可以把它想像成是一個隨著時間發生一連串事件後產生的結果。一個簡單的例子就是如果我們有個 Signal 用來儲存目前滑鼠的位置，隨著我們移動滑鼠，Signal 裡的內容也會跟著變動。你可能會說那直接允許我們改變變數，不要把什麼都規定要 Immutable 不就簡單多了嗎？ Elm 的思考模式是: 沒錯，東西會改變，但我們需要用一些特別的方法在納入改變的同時也能確保狀態的穩定性。至於為什麼這麼執著於 Immutability，歡迎大家參考這篇<a href="https://www.youtube.com/watch?v=I7IdS-PbEgI">演講</a>。</p>

<p>接下來，讓我們來看看 <a href="http://package.elm-lang.org/packages/elm-lang/core/3.0.0/Signal#Signal">Signal</a> 的型別：</p>

<div class="language-elm highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="k">type</span> <span class="kt">Signal</span> <span class="n">a</span>

</code></pre></div></div>

<p>在上例中可以發現 Signal 的內容可以是任何型別。讓我們來思考一下，最終的畫面是個會變動的 <code class="language-plaintext highlighter-rouge">Html</code> 型別，也就是 <code class="language-plaintext highlighter-rouge">Signal Html</code>。記得我們的 <code class="language-plaintext highlighter-rouge">view</code> 函數嗎？畫面是以 <code class="language-plaintext highlighter-rouge">model</code> 為基底，因此，也需要有一個 <code class="language-plaintext highlighter-rouge">Signal Model</code> 型別的變數。我們又透過 <code class="language-plaintext highlighter-rouge">update</code> 函數根據不同的 <code class="language-plaintext highlighter-rouge">Action</code> 來改變 <code class="language-plaintext highlighter-rouge">model</code>，所以最後還需要一個 <code class="language-plaintext highlighter-rouge">Signal Action</code> 型別的變數。如果你還是不太清楚 Signal 的觀念的話，可以看看這個 <a href="http://yang-wei.github.io/elmflux/#/mouseSignal">視覺化 Signal</a> 的 Demo</p>

<p>由於我們開發的應用不可能都像這個計數器這麼簡單，因此，Elm 提供了一個特殊的方法使開發者能夠在複雜的結構下仍然能夠有效率的改動和保留這些 Signal 的狀態。它就是 <code class="language-plaintext highlighter-rouge">Mailbox (信箱)</code> 囉。</p>

<h3 id="mailbox-與-address">Mailbox 與 Address</h3>

<p>Mailbox 隸屬於 <code class="language-plaintext highlighter-rouge">Signal</code> 這個模組下面而且概念就真的像一個信箱一樣，有專屬的<code class="language-plaintext highlighter-rouge">地址 (address)</code> 與信箱裡的內容 <code class="language-plaintext highlighter-rouge">(signal)</code>。讓我們來看看<a href="http://package.elm-lang.org/packages/elm-lang/core/3.0.0/Signal#Mailbox">官方</a>對 <code class="language-plaintext highlighter-rouge">Mailbox</code> 的型別定義：</p>

<div class="language-elm highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="k">type</span> <span class="k">alias</span> <span class="kt">Mailbox</span> <span class="n">a</span> <span class="o">=</span>
    <span class="p">{</span> <span class="n">address</span> <span class="p">:</span> <span class="kt">Address</span> <span class="n">a</span>
    <span class="o">,</span> <span class="n">signal</span> <span class="p">:</span> <span class="kt">Signal</span> <span class="n">a</span>
    <span class="p">}</span>

</code></pre></div></div>

<p>當我們想要修改某個 Signal 內部的值時，必須明確的告知 Elm 這個 Signal 所在的地址，這也就是 <code class="language-plaintext highlighter-rouge">address</code> 的由來。官方提供了 <a href="http://package.elm-lang.org/packages/elm-lang/core/3.0.0/Signal#mailbox">mailbox</a> 這個函數來讓我們快速建立起一個信箱。需要特別注意的是 <code class="language-plaintext highlighter-rouge">mailbox</code> 是小寫的才是函數，大寫的 <code class="language-plaintext highlighter-rouge">Mailbox</code> 是型別喔。</p>

<h2 id="將-signal-套用">將 Signal 套用</h2>

<p>接著我們把剛剛了解的概念套用到計數器上，還記得我們需要哪些 Signal 嗎？先是需要一個 <code class="language-plaintext highlighter-rouge">Signal Action</code>，進而產生 <code class="language-plaintext highlighter-rouge">Signal Model</code>，最後才是我們的結果 <code class="language-plaintext highlighter-rouge">Signal Html</code>。Elm 的其中一個好處就是能夠透過型別來推斷出我們需要哪些函數，最後再一一實作它們。</p>

<div class="language-elm highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="n">actionMailbox</span><span class="p">:</span> <span class="kt">Signal</span><span class="o">.</span><span class="kt">Mailbox</span> <span class="kt">Action</span>
<span class="n">actionMailbox</span> <span class="o">=</span> <span class="kt">Signal</span><span class="o">.</span><span class="n">mailbox</span> <span class="kt">NoOp</span>

</code></pre></div></div>

<p>我們透過 <code class="language-plaintext highlighter-rouge">Signal.mailbox</code> 建立起了專屬 <code class="language-plaintext highlighter-rouge">Action</code> 型別的信箱，這裡使用了當初設定的 <code class="language-plaintext highlighter-rouge">NoOp</code> 作為初始值。這樣我們需要的 <code class="language-plaintext highlighter-rouge">Signal Action</code> 就可以透過 <code class="language-plaintext highlighter-rouge">actionMailbox.signal</code> 來取得，並透過專屬的 <code class="language-plaintext highlighter-rouge">actionMailbox.address</code> 來更新它。</p>

<p>接下來需要的是 <code class="language-plaintext highlighter-rouge">Signal Model</code>:</p>

<div class="language-elm highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="n">modelSignal</span><span class="p">:</span> <span class="kt">Signal</span> <span class="kt">Model</span>
<span class="n">modelSignal</span> <span class="o">=</span> <span class="kt">Signal</span><span class="o">.</span><span class="n">foldp</span> <span class="n">update</span> <span class="n">init</span> <span class="n">actionMailbox</span><span class="o">.</span><span class="n">signal</span>

</code></pre></div></div>

<p>這短短的一行程式碼是將整個程式串接起來的核心。<a href="http://package.elm-lang.org/packages/elm-lang/core/3.0.0/Signal#foldp">foldp</a> (fold from past 的簡寫) 類似於 JavaScript 中的 <code class="language-plaintext highlighter-rouge">reduce</code>，會將我們提供的 Signal (本例中為 <code class="language-plaintext highlighter-rouge">actionMailbox.signal</code>) 中的值取出並透過同樣是我們自定的 <code class="language-plaintext highlighter-rouge">update</code> 函數更新 model 的狀態。而 <code class="language-plaintext highlighter-rouge">init</code> 則是 model 的初始值。</p>

<p>在取得 <code class="language-plaintext highlighter-rouge">modelSignal</code> 後，自然就是把畫面 render 出來囉。在那之前，我們先來更新一下之前所寫的 <code class="language-plaintext highlighter-rouge">view</code> 函數：</p>

<div class="language-elm highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="n">view</span><span class="p">:</span> <span class="kt">Signal</span><span class="o">.</span><span class="kt">Address</span> <span class="kt">Action</span> <span class="o">-&gt;</span> <span class="kt">Model</span> <span class="o">-&gt;</span> <span class="kt">Html</span>
<span class="n">view</span> <span class="n">address</span> <span class="n">model</span> <span class="o">=</span>
    <span class="n">div</span>
        <span class="p">[]</span>
        <span class="p">[</span> <span class="n">button</span> <span class="p">[</span><span class="n">onClick</span> <span class="n">address</span> <span class="kt">Decrease</span><span class="p">]</span> <span class="p">[</span> <span class="n">text</span> <span class="s">"</span><span class="s2">-"</span> <span class="p">]</span>
        <span class="o">,</span> <span class="n">span</span> <span class="p">[]</span> <span class="p">[</span><span class="n">text</span> <span class="p">(</span><span class="n">toString</span> <span class="n">model</span><span class="p">)]</span>
        <span class="o">,</span> <span class="n">button</span> <span class="p">[</span><span class="n">onClick</span> <span class="n">address</span> <span class="kt">Increase</span><span class="p">]</span> <span class="p">[</span> <span class="n">text</span> <span class="s">"</span><span class="s2">+"</span><span class="p">]</span>

</code></pre></div></div>

<p>我們多新增了一個型別為 <code class="language-plaintext highlighter-rouge">Signal.Address Action</code> 的變數。別被它的怪異長相嚇到，其實這只是從 <code class="language-plaintext highlighter-rouge">Signal</code> 模組裡取出 <code class="language-plaintext highlighter-rouge">Address</code> 這個型別而已。而這個 <code class="language-plaintext highlighter-rouge">Address</code> 型別又需要另一個型別變數來完成 (在本例就是 <code class="language-plaintext highlighter-rouge">Action</code>) 才變得這麼嚇人的。假設今天我們在載入模組時使用 <code class="language-plaintext highlighter-rouge">import Signal exposing (Address)</code> 的話，它的型別定義就會是 <code class="language-plaintext highlighter-rouge">Address Action -&gt; Model -&gt; Html</code>，是不是親民一點了呢？</p>

<p>至於為什麼要新增這個名為 <code class="language-plaintext highlighter-rouge">address</code> 的變數相信大家都很清楚，就是為了將新的 <code class="language-plaintext highlighter-rouge">Action</code> 送到它專屬的信箱中並透過一系列的更新，最終將畫面顯示為我們期望的樣子。</p>

<p>好啦，終於到了最後一步。我們需要將 <code class="language-plaintext highlighter-rouge">modelSignal</code> 中的 <code class="language-plaintext highlighter-rouge">model</code> 取出並帶入 <code class="language-plaintext highlighter-rouge">view</code> 中進而產生出一個 <code class="language-plaintext highlighter-rouge">Signal Html</code>。剛好，<code class="language-plaintext highlighter-rouge">Signal</code> 模組中有個符合我們需求的函數，就是大名鼎鼎的 <code class="language-plaintext highlighter-rouge">map</code> 啦。就像是 List 的 <code class="language-plaintext highlighter-rouge">map</code> 一樣， <code class="language-plaintext highlighter-rouge">Signal.map</code> 會幫我們把 <code class="language-plaintext highlighter-rouge">Signal</code> 內的值取出並帶入我們指定的函數內，接著產出一個新的 Signal。</p>

<p>這個指定的函數也是小有學問的。照道理來說，這個指定函數就是 <code class="language-plaintext highlighter-rouge">view</code>。但是 <code class="language-plaintext highlighter-rouge">view</code> 接收的參數不只一個，而是 <code class="language-plaintext highlighter-rouge">address</code>，再來才是 <code class="language-plaintext highlighter-rouge">map</code> 會丟給我們的 <code class="language-plaintext highlighter-rouge">model</code>。好在，在 Elm 的世界裡，所有函數都是預設可以 <a href="http://www.sitepoint.com/currying-in-functional-javascript/">Curry</a> 的。意味著，我們只需要將 <code class="language-plaintext highlighter-rouge">address</code> 帶入後就可以取得一個型別為 <code class="language-plaintext highlighter-rouge">Model -&gt; Html</code> 的函數。至於這個 <code class="language-plaintext highlighter-rouge">address</code> 要帶什麼值呢？當然就是 <code class="language-plaintext highlighter-rouge">actionMailbox.address</code> 囉！</p>

<div class="language-elm highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="n">main</span><span class="p">:</span> <span class="kt">Signal</span> <span class="kt">Html</span>
<span class="n">main</span> <span class="o">=</span> <span class="kt">Signal</span><span class="o">.</span><span class="n">map</span> <span class="p">(</span><span class="n">view</span> <span class="n">actionMailbox</span><span class="o">.</span><span class="n">address</span><span class="p">)</span> <span class="n">modelSignal</span>

</code></pre></div></div>

<p>最終完成的程式碼如下，一樣歡迎大家複製貼上到 <a href="http://elm-lang.org/try">elm-lang.org/try</a> 實驗看看：</p>

<script src="https://gist.github.com/Rhadow/bd80cb378b3bcdcc4a00eb6678f6535f.js"></script>

<h2 id="結語">結語</h2>

<p>在看完本篇後，希望大家都能夠明白 <a href="https://github.com/evancz/start-app">Start-App</a> 在背後為我們做了些什麼，也希望大家能夠瞭解 address 的由來。未來在寫起 Elm 應用程式時也更清楚整個來龍去脈，在需要變化的時候，也不會受限於 <a href="https://github.com/evancz/start-app">Start-App</a> 而能夠更靈活的發揮！</p>
:ET