I"I<p>最近有在使用 React 搭配 Flux 架構的開發者們應該都對
<a href="http://facebook.github.io/immutable-js/">Immutable.js</a> 不會太陌生。這個函式庫能夠創建不可變的資料結構，使開發者能更清楚的理解目前資料的狀態，更能優化程式處理速度。同時，immutable.js 也與 React 內提供的 <code class="language-plaintext highlighter-rouge">pureRenderMixin</code> 相容，使本來就很快的 React 在速度上又提升到更高的層次。</p>

<h2 id="immutablejs-內的資料結構">Immutable.js 內的資料結構</h2>

<p>在 Immutable.js 的世界裡有一套屬於它自己的規則，如果我們想要擁有它所提供的便利性，就必須先把我們熟知的陣列與物件等轉換成它內部的資料結構來做更進一步的操作。由於 Immutable.js 有提供各式各樣不同的結構，本文將只介紹較基本且常用到的 List，Map 與 Sequence。對於其他結構有興趣的讀者，請閱讀<a href="http://facebook.github.io/immutable-js/docs/#/">官方提供的說明頁</a>。</p>

<h3 id="fromjs">fromJS()</h3>

<p>在介紹這些內部結構之前，我們先來瞭解一下該如何將 JavaScript 轉換成 Immutable.js 可用的結構。轉換的方式有很多，<code class="language-plaintext highlighter-rouge">fromJS()</code>是比較直接的一種。這個函式的主要功能就是將你丟給他的 JavaScript 物件或陣列轉換成對應的 Immutable.js 結構。它的第二個參數則是一個 callback，讓開發者能夠自訂轉換出的最終結構，如不特別提供這個參數的話，預設會將陣列轉換成 List，物件轉換成 Map。</p>

<p>小提醒：<code class="language-plaintext highlighter-rouge">fromJS()</code>做的轉換是深轉換 (Deep Conversion)。</p>

<h3 id="list">List</h3>

<p>在 Immutable 的世界裡，List 就相當於 JavaScript 的陣列。我們可以透過 <code class="language-plaintext highlighter-rouge">List.of()</code> 建立一個 List。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">list1</span><span class="o">=</span> <span class="nx">Immutable</span><span class="p">.</span><span class="nx">List</span><span class="p">.</span><span class="k">of</span><span class="p">(</span><span class="dl">'</span><span class="s1">a</span><span class="dl">'</span><span class="p">,</span><span class="dl">'</span><span class="s1">b</span><span class="dl">'</span><span class="p">,</span><span class="dl">'</span><span class="s1">c</span><span class="dl">'</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">list2</span> <span class="o">=</span> <span class="nx">list1</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="dl">'</span><span class="s1">d</span><span class="dl">'</span><span class="p">);</span> <span class="c1">// 'a','b','c','d'</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">list1</span><span class="p">.</span><span class="nx">size</span><span class="p">);</span> <span class="c1">// 3</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">list2</span><span class="p">.</span><span class="nx">size</span><span class="p">);</span> <span class="c1">// 4</span>
</code></pre></div></div>

<p>如同上例所示，list1 並沒有因為 <code class="language-plaintext highlighter-rouge">push()</code> 的關係改變了自已原本的結構，反而是生成了一個新的 List，而我們將它存為 list2。除此之外，許多 JavaScript 陣列原生方法例如 <code class="language-plaintext highlighter-rouge">shift()</code>，<code class="language-plaintext highlighter-rouge">unshift()</code>，<code class="language-plaintext highlighter-rouge">pop()</code> 等等，Immutable.js 都有實作對應的 API，讓開發者可以無縫接軌的使用。</p>

<p>理解如何生成 List 後，讓我們來看看如何取值與修改值吧。
如果 List 只有很單純的一層時，使用 <code class="language-plaintext highlighter-rouge">get()</code> 與 <code class="language-plaintext highlighter-rouge">set()</code> :</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">list1</span> <span class="o">=</span> <span class="nx">Immutable</span><span class="p">.</span><span class="nx">List</span><span class="p">.</span><span class="k">of</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">list2</span> <span class="o">=</span> <span class="nx">list1</span><span class="p">.</span><span class="kd">set</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">);</span>
<span class="c1">// list2 相當於 Immutable.List.of(1,5,3,4)</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">list2</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span> <span class="c1">// 5</span>
</code></pre></div></div>
<p>使用的方式很簡單，就像陣列一樣透過 index 的方式取值改值。</p>

<p>當 List 內部又有包其他 List 時，則需要使用 <code class="language-plaintext highlighter-rouge">setIn()</code> 與 <code class="language-plaintext highlighter-rouge">getIn()</code> :</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">list1</span> <span class="o">=</span> <span class="nx">Immutable</span><span class="p">.</span><span class="nx">fromJS</span><span class="p">([</span><span class="mi">1</span><span class="p">,[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span><span class="mi">4</span><span class="p">]);</span>
<span class="kd">var</span> <span class="nx">list2</span> <span class="o">=</span> <span class="nx">list1</span><span class="p">.</span><span class="nx">setIn</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span><span class="mi">100</span><span class="p">);</span>
<span class="c1">// list2 相當於 Immutable.fromJS([1,[2,100],4])</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">list2</span><span class="p">.</span><span class="nx">getIn</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]));</span> <span class="c1">// 2</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">list2</span><span class="p">.</span><span class="nx">getIn</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]));</span> <span class="c1">// 100</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">setIn()</code> 和 <code class="language-plaintext highlighter-rouge">getIn()</code> 的用法也很簡單，陣列裡的數字其實就是每個層級的 Index。我們只要指到需要拿取或修改的 Index 就可以了。
上例在 <code class="language-plaintext highlighter-rouge">setIn()</code> 裡的 [1,1] 其實就是要取得 [1,[2,3],4] 裡的 [2,3] 裡的 3 並將它修改成 100。同理也可應用於取值。</p>

<h3 id="map">Map</h3>

<p>Map 對應到的則是 JavaScript 中的物件。注意：物件並不等於是 Map，從 ES6 開始後，JavaScript 也有原生的 Map。建立 Map 與設值取值其實和 List 差不多:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">map1</span> <span class="o">=</span> <span class="nx">Immutable</span><span class="p">.</span><span class="nb">Map</span><span class="p">({</span><span class="na">js</span><span class="p">:</span><span class="dl">'</span><span class="s1">AngularJS</span><span class="dl">'</span><span class="p">,</span><span class="na">css</span><span class="p">:</span><span class="dl">'</span><span class="s1">Bootstrap</span><span class="dl">'</span><span class="p">});</span>
<span class="kd">var</span> <span class="nx">map2</span> <span class="o">=</span> <span class="nx">map1</span><span class="p">.</span><span class="kd">set</span><span class="p">(</span><span class="dl">'</span><span class="s1">js</span><span class="dl">'</span><span class="p">,</span><span class="dl">'</span><span class="s1">ReactJS</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">map1</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="dl">'</span><span class="s1">js</span><span class="dl">'</span><span class="p">));</span> <span class="c1">// 'AngularJS'</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">map2</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="dl">'</span><span class="s1">js</span><span class="dl">'</span><span class="p">));</span> <span class="c1">// 'ReactJS'</span>
</code></pre></div></div>

<p>深度取值與改值也是使用 <code class="language-plaintext highlighter-rouge">setIn()</code> 與 <code class="language-plaintext highlighter-rouge">getIn()</code> :</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">map1</span> <span class="o">=</span> <span class="nx">Immutable</span><span class="p">.</span><span class="nx">fromJS</span><span class="p">({</span>
    <span class="na">name</span><span class="p">:</span> <span class="dl">'</span><span class="s1">Howard</span><span class="dl">'</span><span class="p">,</span>
    <span class="na">birthday</span><span class="p">:</span> <span class="p">{</span>
        <span class="na">year</span><span class="p">:</span> <span class="mi">1988</span><span class="p">,</span>
        <span class="na">month</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span>
        <span class="na">day</span><span class="p">:</span> <span class="mi">28</span>
    <span class="p">},</span>
<span class="p">});</span>
<span class="kd">var</span> <span class="nx">map2</span> <span class="o">=</span> <span class="nx">map1</span><span class="p">.</span><span class="nx">setIn</span><span class="p">([</span><span class="dl">'</span><span class="s1">birthday</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">year</span><span class="dl">'</span><span class="p">],</span> <span class="mi">2015</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">map1</span><span class="p">.</span><span class="nx">getIn</span><span class="p">([</span><span class="dl">'</span><span class="s1">birthday</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">year</span><span class="dl">'</span><span class="p">]));</span> <span class="c1">// 1988</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">map2</span><span class="p">.</span><span class="nx">getIn</span><span class="p">([</span><span class="dl">'</span><span class="s1">birthday</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">year</span><span class="dl">'</span><span class="p">]));</span> <span class="c1">// 2015</span>
</code></pre></div></div>

<h3 id="sequence">Sequence</h3>

<p>Immutable.js 的設計靈感其實有一部分來自於 Clojure, Scala, Haskell 這些函數式編程語言。因此 Immutable.js 裡有個特殊的結構叫 Sequence。Map 和 List 都可以透過 <code class="language-plaintext highlighter-rouge">toSeq()</code> 這個方法來轉換成 Sequence。 Sequence 有兩個很重要的特性：</p>

<ul>
  <li>Immutable (不可變)</li>
  <li>Lazy (延遲)</li>
</ul>

<p>Immutable 我相信你應該很了解它的意思了，但延遲這特性是怎麼回事？我們直接來看看官方提供的例子好了：</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">oddSquares</span> <span class="o">=</span> <span class="nx">Immutable</span><span class="p">.</span><span class="nx">Seq</span><span class="p">.</span><span class="k">of</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">)</span>
  <span class="p">.</span><span class="nx">filter</span><span class="p">(</span><span class="nx">x</span> <span class="o">=&gt;</span> <span class="nx">x</span> <span class="o">%</span> <span class="mi">2</span><span class="p">).</span><span class="nx">map</span><span class="p">(</span><span class="nx">x</span> <span class="o">=&gt;</span> <span class="nx">x</span> <span class="o">*</span> <span class="nx">x</span><span class="p">);</span>
</code></pre></div></div>

<p>如果上面的例子是一般的 List 而不是 Sequence 的話，oddSquares 其實是等於 <code class="language-plaintext highlighter-rouge">[1,9,25,49]</code>。但因為 Sequence 擁有延遲的特性，在你要求它給你值之前他是不會把結果計算出來的。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">oddSquares</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span> <span class="c1">// 9</span>
</code></pre></div></div>
<p>當我們透過以上程式碼向它取值時，oddSquares 才會把 9 給我們。特別注意的是，它也不會繼續做後面 25 與 49 的運算。因為延遲的關係，Sequence 只會做到我們向它要求的地方。也因此，程式其實省去了很多不必要的運算，這也是為什麼 Immutable.js 會優化速度的原因之一。</p>

<p>為了理解，我們再來看一個官方提供的例子：</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">Immutable</span><span class="p">.</span><span class="nx">Range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="kc">Infinity</span><span class="p">)</span>
  <span class="p">.</span><span class="nx">skip</span><span class="p">(</span><span class="mi">1000</span><span class="p">)</span>
  <span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">n</span> <span class="o">=&gt;</span> <span class="o">-</span><span class="nx">n</span><span class="p">)</span>
  <span class="p">.</span><span class="nx">filter</span><span class="p">(</span><span class="nx">n</span> <span class="o">=&gt;</span> <span class="nx">n</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span>
  <span class="p">.</span><span class="nx">take</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
  <span class="p">.</span><span class="nx">reduce</span><span class="p">((</span><span class="nx">r</span><span class="p">,</span> <span class="nx">n</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">r</span> <span class="o">*</span> <span class="nx">n</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="c1">// 1006008</span>
</code></pre></div></div>

<p>Range 結構本身就是 Sequence，所以我們不需要特地使用 <code class="language-plaintext highlighter-rouge">toSeq()</code> 來做轉換。在這個範例中，我們可以把它想像成是一個類似陣列的結構。</p>

<p>首先，建立一個類似 <code class="language-plaintext highlighter-rouge">[1,2,3...Infinity]</code> 的 Range。因為 Immutable 的關係，每一步其實都是一個新的 Range，但由於 Lazy 的特性，這些為了取值而在過程中建立的 Range 都不會被儲存。</p>

<p><code class="language-plaintext highlighter-rouge">skip(1000)</code> 的作用是跳過 Range 前 1000 個值。新的 Range 長這樣：<code class="language-plaintext highlighter-rouge">[1001, 1002...Infinity]</code>。</p>

<p>接下來的 <code class="language-plaintext highlighter-rouge">map()</code> 和 <code class="language-plaintext highlighter-rouge">filter()</code> 會把新的 Range 過濾成 <code class="language-plaintext highlighter-rouge">[-1002, -1004, -1006...Infinity]</code>。</p>

<p><code class="language-plaintext highlighter-rouge">take(2)</code> 則是取 Range 內最前面兩筆資料。</p>

<p>最後再透過 <code class="language-plaintext highlighter-rouge">reduce()</code> 相乘得到 1006008。</p>

<p>以上這些運算如果不是透過 Sequence 延遲這個特性，在 <code class="language-plaintext highlighter-rouge">take(2)</code> 前的每一步都有大量的運算，電腦根本無法負荷。</p>

<h2 id="總結">總結</h2>

<p>相信耐心讀完本文的讀者應該都對 Immutable.js 有了基本的了解。未來有機會的話也希望與各位分享如何將 Immutable.js 應用在 Flux 架構中。想要深入研究的讀者也可以閱讀<a href="http://facebook.github.io/immutable-js/docs/#/">官方文件</a>或觀看 Immutable.js 的開發者 Lee Byron 在 <a href="https://www.youtube.com/watch?v=I7IdS-PbEgI&amp;list=PLb0IAmt7-GS1cbw4qonlQztYV1TAW0sCr&amp;index=13">2015 F8 的演講</a>。</p>
:ET